xquery version "3.0";

module namespace app="http://edirom.de/smufl-browser/app";

import module namespace templates="http://exist-db.org/xquery/templates" ;
import module namespace config="http://edirom.de/smufl-browser/config" at "config.xqm";
import module namespace functx="http://www.functx.com";

declare namespace tei="http://www.tei-c.org/ns/1.0";
declare namespace request="http://exist-db.org/xquery/request";

declare variable $app:entriesPerPage := 10 ;

(:~
 : This is a sample templating function. It will be called by the templating module if
 : it encounters an HTML element with an attribute data-template="app:test" 
 : or class="app:test" (deprecated). The function has to take at least 2 default
 : parameters. Additional parameters will be mapped to matching request or session parameters.
 : 
 : @param $node the HTML node with the attribute which triggered this call
 : @param $model a map containing arbitrary data - used to pass information between template calls
 :)
declare function app:test($node as node(), $model as map(*)) {
    <p>Dummy template output generated by function app:test at {current-dateTime()}. The templating
        function was triggered by the class attribute <code>class="app:test"</code>.</p>
};

declare function app:charID($node as node(), $model as map(*)) as element(h1) {
    <h1>{map:get($model, 'char')/normalize-space(@xml:id)}</h1>
};

declare function app:charDesc($node as node(), $model as map(*)) as element(dl) {
    let $char := map:get($model, 'char')
    return 
        <dl class="charDesc">
            <dt>Character name</dt>
            <dd>{normalize-space($char/tei:charName)}</dd>
            <dt>SMuFL codepoint</dt>
            <dd>{normalize-space($char/tei:mapping[@type='smufl'])}</dd>
            <dt>HTML entity (hex)</dt>
            <dd>{'&amp;#x' || substring-after(normalize-space($char/tei:mapping[@type='smufl']), 'U+') || ';'}</dd>
            {if($char/tei:mapping[@type='unicode']) then ( 
            <dt>Unicode</dt>,
            <dd>{normalize-space($char/tei:mapping[@type='unicode'])}</dd>)
            else ()}
            <dt>Range</dt>
            <dd>{normalize-space($char/ancestor::tei:charDecl/tei:desc)}</dd>
            <dt>Classes</dt>
            <dd>{string-join($char//tei:item/normalize-space(), ', ')}</dd>
            <dt>TEI code for embedding</dt>
            <dd><code>&lt;g ref="{string-join(($config:server-url, normalize-space($char/@xml:id) || '.xml'), '/')}"/&gt;</code></dd>
        </dl>
};

declare function app:charImage($node as node(), $model as map(*)) as element(img) {
    let $char := map:get($model, 'char')
    let $url := $char/tei:graphic/normalize-space(@url)
    return 
        <img src="{$url}" class="charImage"/>
};

declare 
    %templates:wrap
    %templates:default("ranges", "all")
    function app:ranges-list($node as node(), $model as map(*), $ranges as xs:string*) as element(option)* {
        for $range in $config:charDecl//tei:desc
        let $name := normalize-space($range)
        order by $name ascending
        return 
            <option value="{$name}">{
                if($ranges = $name) then attribute {'selected'} {'selected'} 
                else (),
                $name
            }</option>
};

declare 
    %templates:wrap
    %templates:default("glyphnames", "all")
    function app:glyphnames-list($node as node(), $model as map(*), $glyphnames as xs:string*) as element(option)* {
        for $glyph in $config:charDecl//tei:char
        let $name := normalize-space($glyph/@xml:id)
        order by $name ascending
        return 
            <option value="{$name}">{
                if($glyphnames = $name) then attribute {'selected'} {'selected'} 
                else (),
                $name
            }</option>
};

declare 
    %templates:wrap 
    %templates:default("classes", "all")
    function app:classes-list($node as node(), $model as map(*), $classes as xs:string*) as element(option)* {
        for $class in distinct-values($config:charDecl//tei:item)
        let $name := normalize-space($class)
        order by $name ascending
        return 
            <option value="{$name}">{
                if($classes = $name) then attribute {'selected'} {'selected'} 
                else (),
                $name
            }</option>
};

declare 
    %templates:wrap
    %templates:default("range", "all")
    %templates:default("class", "all")
    %templates:default("glyphname", "all")
    function app:list-chars($node as node(), $model as map(*), $range as xs:string*, $class as xs:string*, $glyphname as xs:string*) as map(*) {
        let $chars := 
            if(($range,$class,$glyphname) != 'all') then (
                $config:charDecl//tei:char[.//tei:item = $class] | 
                $config:charDecl//tei:char[parent::tei:charDecl/tei:desc = $range][@xml:id] |
                $config:charDecl//id($glyphname)
            )
            else $config:charDecl//tei:char[@xml:id]
        return 
            map { "chars" := $chars }
};

declare
    %templates:default("page", "1")
    function app:one-page($node as node(), $model as map(*), $page as xs:string) as map(*) {
        let $page := if($page castable as xs:int) then xs:int($page) else 1
        return
            map { "chars" := subsequence($model('chars'), ($page - 1) * 10 + 1, $app:entriesPerPage) }
};


declare
    %templates:wrap
    %templates:default("page", "1")
    function app:pagination($node as node(), $model as map(*), $page as xs:string) as element(li)* {
        let $page := if($page castable as xs:int) then xs:int($page) else 1
        let $page-link := function ($page as xs:int){
            'index.html?page=' || $page || string-join(
                request:get-parameter-names()[. != 'page'] ! (
                    '&amp;' || string(.) || '=' || string-join(
                        request:get-parameter(., ''),
                        '&amp;' || string(.) || '=')
                    ), 
                '')
            }
        let $last-page := ceiling(count($model('chars')) div $app:entriesPerPage) 
        return (
            <li>{
                if($page le 1) then (
                    attribute {'class'}{'disabled'},
                    <span>&#x00AB; previous</span>
                )
                else <a href="{$page-link($page - 1)}">&#x00AB; previous</a> 
            }</li>,
            if($page gt 3) then <li><a href="{$page-link(1)}">1</a></li> else (),
            if($page gt 4) then <li><a href="{$page-link(2)}">2</a></li> else (),
            if($page gt 5) then <li><span>…</span></li> else (),
            ($page - 2, $page - 1)[. gt 0] ! <li><a href="{$page-link(.)}">{string(.)}</a></li>,
            <li class="active"><span>{$page}</span></li>,
            ($page + 1, $page + 2)[. le $last-page] ! <li><a href="{$page-link(.)}">{string(.)}</a></li>,
            if($page + 4 lt $last-page) then <li><span>…</span></li> else (),
            if($page + 3 lt $last-page) then <li><a href="{$page-link($last-page - 1)}">{$last-page - 1}</a></li> else (),
            if($page + 2 lt $last-page) then <li><a href="{$page-link($last-page)}">{$last-page}</a></li> else (),
            <li>{
                if($page ge $last-page) then (
                    attribute {'class'}{'disabled'},
                    <span>next &#x00BB;</span>
                )
                else <a href="{$page-link($page + 1)}">next &#x00BB;</a> 
            }</li>
        )
};
